import {
  getConfigHash,
  loadConfig
} from "./chunk-HFLDWPJA.js";
import {
  validate
} from "./chunk-2ZOW45YZ.js";
import {
  remarkInclude
} from "./chunk-MK7EXW7O.js";
import "./chunk-DRVUBK5B.js";

// src/loader-mdx.ts
import * as path2 from "node:path";
import { parse } from "node:querystring";
import grayMatter from "gray-matter";

// src/utils/build-mdx.ts
import { createProcessor } from "@mdx-js/mdx";
var cache = /* @__PURE__ */ new Map();
async function buildMDX(cacheKey, source, options = {}) {
  const { filePath, frontmatter, data, ...rest } = options;
  let format = options.format;
  if (!format && filePath) {
    format = filePath.endsWith(".mdx") ? "mdx" : "md";
  }
  format ??= "mdx";
  const key = `${cacheKey}:${format}`;
  let cached = cache.get(key);
  if (cached === void 0) {
    cached = createProcessor({
      outputFormat: "program",
      development: process.env.NODE_ENV === "development",
      ...rest,
      remarkPlugins: [remarkInclude, ...rest.remarkPlugins ?? []],
      format
    });
    cache.set(key, cached);
  }
  return cached.process({
    value: source,
    path: filePath,
    data: {
      ...data,
      frontmatter,
      _compiler: options._compiler
    }
  });
}

// src/utils/git-timestamp.ts
import path from "node:path";
import fs from "node:fs";
import { spawn } from "cross-spawn";
var cache2 = /* @__PURE__ */ new Map();
function getGitTimestamp(file) {
  const cachedTimestamp = cache2.get(file);
  if (cachedTimestamp) return Promise.resolve(cachedTimestamp);
  return new Promise((resolve, reject) => {
    const cwd = path.dirname(file);
    if (!fs.existsSync(cwd)) {
      resolve(void 0);
      return;
    }
    const fileName = path.basename(file);
    const child = spawn("git", ["log", "-1", '--pretty="%ai"', fileName], {
      cwd
    });
    let output;
    child.stdout.on("data", (d) => output = new Date(String(d)));
    child.on("close", () => {
      if (output) cache2.set(file, output);
      resolve(output);
    });
    child.on("error", reject);
  });
}

// src/loader-mdx.ts
function parseQuery(query) {
  let collection;
  let hash;
  const parsed = parse(query.slice(1));
  if (parsed.collection && typeof parsed.collection === "string")
    collection = parsed.collection;
  if (parsed.hash && typeof parsed.hash === "string") hash = parsed.hash;
  return { collection, hash };
}
async function loader(source, callback) {
  this.cacheable(true);
  const context = this.context;
  const filePath = this.resourcePath;
  const { _ctx } = this.getOptions();
  const matter = grayMatter(source);
  const {
    hash: configHash = await getConfigHash(_ctx.configPath),
    collection: collectionId
  } = parseQuery(this.resourceQuery);
  const config = await loadConfig(_ctx.configPath, configHash);
  let collection = collectionId !== void 0 ? config.collections.get(collectionId) : void 0;
  if (collection && collection.type === "docs") collection = collection.docs;
  if (collection && collection.type !== "doc") {
    collection = void 0;
  }
  let mdxOptions = collection?.mdxOptions;
  if (!mdxOptions) {
    const { getDefaultMDXOptions } = await import("./mdx-options-CAU273O3.js");
    config._mdx_loader ??= {};
    const extendedOptions = config.global?.mdxOptions;
    config._mdx_loader.cachedProcessorOptions ??= typeof extendedOptions === "function" ? getDefaultMDXOptions(await extendedOptions()) : getDefaultMDXOptions(extendedOptions ?? {});
    mdxOptions = config._mdx_loader.cachedProcessorOptions;
  }
  if (collection?.schema) {
    matter.data = await validate(
      collection.schema,
      matter.data,
      {
        source,
        path: filePath
      },
      `invalid frontmatter in ${filePath}`
    );
  }
  let timestamp;
  if (config.global?.lastModifiedTime === "git")
    timestamp = (await getGitTimestamp(filePath))?.getTime();
  try {
    const lineOffset = "\n".repeat(
      this.mode === "development" ? lines(source) - lines(matter.content) : 0
    );
    const file = await buildMDX(
      `${configHash}:${collectionId ?? "global"}`,
      lineOffset + matter.content,
      {
        development: this.mode === "development",
        ...mdxOptions,
        filePath,
        frontmatter: matter.data,
        data: {
          lastModified: timestamp
        },
        _compiler: this
      }
    );
    callback(void 0, String(file.value), file.map ?? void 0);
  } catch (error) {
    if (!(error instanceof Error)) throw error;
    const fpath = path2.relative(context, filePath);
    error.message = `${fpath}:${error.name}: ${error.message}`;
    callback(error);
  }
}
function lines(s) {
  let num = 0;
  for (const c of s) {
    if (c === "\n") num++;
  }
  return num;
}
export {
  loader as default
};
