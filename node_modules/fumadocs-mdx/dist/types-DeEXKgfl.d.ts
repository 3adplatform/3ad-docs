import { D as DocCollection, b as MetaCollection, c as DocsCollection, G as GlobalConfig, F as FileInfo, M as MarkdownProps, B as BaseCollectionEntry } from './define-Cbpc-b73.js';
import { StandardSchemaV1 } from '@standard-schema/spec';
import { Source, PageData, MetaData } from 'fumadocs-core/source';
import { ProcessorOptions } from '@mdx-js/mdx';
import { MDXOptions } from '@fumadocs/mdx-remote';

interface LoadedConfig {
    collections: Map<string, DocCollection | MetaCollection | DocsCollection>;
    global?: GlobalConfig;
    _mdx_loader?: {
        cachedProcessorOptions?: ProcessorOptions;
    };
    _mdx_async?: {
        cachedMdxOptions?: MDXOptions;
    };
}

interface RuntimeFile {
    info: FileInfo;
    data: Record<string, unknown>;
}
interface AsyncRuntimeFile {
    info: FileInfo;
    data: Record<string, unknown>;
    content: string;
}
type DocOut<Schema extends StandardSchemaV1> = Override<MarkdownProps & {
    /**
     * Read the original content of file from file system.
     */
    get content(): string;
}, StandardSchemaV1.InferOutput<Schema> & BaseCollectionEntry>;
type Override<A, B> = Omit<A, keyof B> & B;
type MetaOut<Schema extends StandardSchemaV1> = StandardSchemaV1.InferOutput<Schema> & BaseCollectionEntry;
interface Runtime {
    doc: <C>(files: RuntimeFile[]) => C extends {
        type: 'doc';
        _type: {
            schema: infer Schema extends StandardSchemaV1;
        };
    } ? DocOut<Schema>[] : never;
    meta: <C>(files: RuntimeFile[]) => C extends {
        type: 'meta';
        _type: {
            schema: infer Schema extends StandardSchemaV1;
        };
    } ? MetaOut<Schema>[] : never;
    docs: <C>(docs: RuntimeFile[], metas: RuntimeFile[]) => C extends {
        type: 'docs';
        docs: {
            type: 'doc';
            _type: {
                schema: infer DocSchema extends StandardSchemaV1;
            };
        };
        meta: {
            type: 'meta';
            _type: {
                schema: infer MetaSchema extends StandardSchemaV1;
            };
        };
    } ? {
        docs: DocOut<DocSchema>[];
        meta: MetaOut<MetaSchema>[];
        toFumadocsSource: () => Source<{
            pageData: DocOut<DocSchema> extends PageData ? DocOut<DocSchema> : never;
            metaData: MetaOut<MetaSchema> extends MetaData ? MetaOut<MetaSchema> : never;
        }>;
    } : never;
}
type AsyncDocOut<Schema extends StandardSchemaV1> = StandardSchemaV1.InferOutput<Schema> & BaseCollectionEntry & {
    content: string;
    load: () => Promise<MarkdownProps>;
};
interface RuntimeAsync {
    doc: <C>(files: AsyncRuntimeFile[], collection: string, config: LoadedConfig) => C extends {
        type: 'doc';
        _type: {
            schema: infer Schema extends StandardSchemaV1;
        };
    } ? AsyncDocOut<Schema>[] : never;
    docs: <C>(docs: AsyncRuntimeFile[], metas: RuntimeFile[], collection: string, config: LoadedConfig) => C extends {
        type: 'docs';
        docs: {
            type: 'doc';
            _type: {
                schema: infer DocSchema extends StandardSchemaV1;
            };
        };
        meta: {
            type: 'meta';
            _type: {
                schema: infer MetaSchema extends StandardSchemaV1;
            };
        };
    } ? {
        docs: AsyncDocOut<DocSchema>[];
        meta: MetaOut<MetaSchema>[];
        toFumadocsSource: () => Source<{
            pageData: AsyncDocOut<DocSchema> extends PageData ? AsyncDocOut<DocSchema> : never;
            metaData: MetaOut<MetaSchema> extends MetaData ? MetaOut<MetaSchema> : never;
        }>;
    } : never;
}

export type { LoadedConfig as L, Runtime as R, RuntimeAsync as a };
