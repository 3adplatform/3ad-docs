"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/mdx-plugins/remark-exports.ts
function remarkMdxExport({ values }) {
  return (tree, vfile) => {
    for (const name of values) {
      if (!(name in vfile.data)) return;
      tree.children.unshift(getMdastExport(name, vfile.data[name]));
    }
  };
}
function getMdastExport(name, value) {
  return {
    type: "mdxjsEsm",
    value: "",
    data: {
      estree: {
        type: "Program",
        sourceType: "module",
        body: [
          {
            type: "ExportNamedDeclaration",
            specifiers: [],
            source: null,
            declaration: {
              type: "VariableDeclaration",
              kind: "let",
              declarations: [
                {
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name
                  },
                  init: (0, import_estree_util_value_to_estree.valueToEstree)(value)
                }
              ]
            }
          }
        ]
      }
    }
  };
}
var import_estree_util_value_to_estree;
var init_remark_exports = __esm({
  "src/mdx-plugins/remark-exports.ts"() {
    "use strict";
    import_estree_util_value_to_estree = require("estree-util-value-to-estree");
  }
});

// src/utils/mdx-options.ts
var mdx_options_exports = {};
__export(mdx_options_exports, {
  getDefaultMDXOptions: () => getDefaultMDXOptions
});
function pluginOption(def, options = []) {
  const list = def(Array.isArray(options) ? options : []).filter(
    Boolean
  );
  if (typeof options === "function") {
    return options(list);
  }
  return list;
}
function getDefaultMDXOptions({
  valueToExport = [],
  rehypeCodeOptions,
  remarkImageOptions,
  remarkHeadingOptions,
  remarkStructureOptions,
  remarkCodeTabOptions,
  ...mdxOptions
}) {
  const mdxExports = [
    "structuredData",
    "frontmatter",
    "lastModified",
    ...valueToExport
  ];
  const remarkPlugins = pluginOption(
    (v) => [
      plugins.remarkGfm,
      [
        plugins.remarkHeading,
        {
          generateToc: false,
          ...remarkHeadingOptions
        }
      ],
      remarkImageOptions !== false && [plugins.remarkImage, remarkImageOptions],
      // Fumadocs 14 compatibility
      "remarkCodeTab" in plugins && remarkCodeTabOptions !== false && plugins.remarkCodeTab,
      ...v,
      remarkStructureOptions !== false && [
        plugins.remarkStructure,
        remarkStructureOptions
      ],
      [remarkMdxExport, { values: mdxExports }]
    ],
    mdxOptions.remarkPlugins
  );
  const rehypePlugins = pluginOption(
    (v) => [
      rehypeCodeOptions !== false && [plugins.rehypeCode, rehypeCodeOptions],
      ...v,
      [plugins.rehypeToc]
    ],
    mdxOptions.rehypePlugins
  );
  return {
    ...mdxOptions,
    remarkPlugins,
    rehypePlugins
  };
}
var plugins;
var init_mdx_options = __esm({
  "src/utils/mdx-options.ts"() {
    "use strict";
    plugins = __toESM(require("fumadocs-core/mdx-plugins"), 1);
    init_remark_exports();
  }
});

// src/loader-mdx.ts
var loader_mdx_exports = {};
__export(loader_mdx_exports, {
  default: () => loader
});
module.exports = __toCommonJS(loader_mdx_exports);
var path4 = __toESM(require("path"), 1);
var import_node_querystring = require("querystring");
var import_gray_matter2 = __toESM(require("gray-matter"), 1);

// src/utils/config.ts
var fs = __toESM(require("fs/promises"), 1);
var path = __toESM(require("path"), 1);
var import_node_url = require("url");

// src/config/build.ts
function buildConfig(config) {
  const collections = /* @__PURE__ */ new Map();
  let globalConfig;
  for (const [k, v] of Object.entries(config)) {
    if (!v) {
      continue;
    }
    if (typeof v === "object" && "type" in v) {
      if (v.type === "docs") {
        collections.set(k, v);
        continue;
      }
      if (v.type === "doc" || v.type === "meta") {
        collections.set(k, v);
        continue;
      }
    }
    if (k === "default") {
      globalConfig = v;
      continue;
    }
    return [
      `Unknown export "${k}", you can only export collections from source configuration file.`,
      null
    ];
  }
  return [
    null,
    {
      global: globalConfig,
      collections
    }
  ];
}

// src/utils/config.ts
var cache = null;
async function compileConfig(configPath, outDir) {
  const { build } = await import("esbuild");
  const transformed = await build({
    entryPoints: [{ in: configPath, out: "source.config" }],
    bundle: true,
    outdir: outDir,
    target: "node18",
    write: true,
    platform: "node",
    format: "esm",
    packages: "external",
    outExtension: {
      ".js": ".mjs"
    },
    allowOverwrite: true
  });
  if (transformed.errors.length > 0) {
    throw new Error("failed to compile configuration file");
  }
}
async function loadConfig(configPath, hash, build = false) {
  if (cache && cache.hash === hash) {
    return await cache.config;
  }
  if (build) await compileConfig(configPath, ".source");
  const url = (0, import_node_url.pathToFileURL)(path.resolve(".source/source.config.mjs"));
  const config = import(`${url.href}?hash=${hash}`).then((loaded) => {
    const [err, config2] = buildConfig(
      // every call to `loadConfig` will cause the previous cache to be ignored
      loaded
    );
    if (err !== null) throw new Error(err);
    return config2;
  });
  cache = { config, hash };
  return await config;
}
async function getConfigHash(configPath) {
  const stats = await fs.stat(configPath).catch(() => void 0);
  if (stats) {
    return stats.mtime.getTime().toString();
  }
  throw new Error("Cannot find config file");
}

// src/utils/build-mdx.ts
var import_mdx = require("@mdx-js/mdx");

// src/mdx-plugins/remark-include.ts
var import_unist_util_visit = require("unist-util-visit");
var path2 = __toESM(require("path"), 1);
var fs2 = __toESM(require("fs/promises"), 1);
var import_gray_matter = __toESM(require("gray-matter"), 1);
function flattenNode(node) {
  if ("children" in node)
    return node.children.map((child) => flattenNode(child)).join("");
  if ("value" in node) return node.value;
  return "";
}
function remarkInclude() {
  const TagName = "include";
  async function update(tree, file, processor, compiler) {
    const queue = [];
    (0, import_unist_util_visit.visit)(
      tree,
      ["mdxJsxFlowElement", "mdxJsxTextElement"],
      (node, _, parent) => {
        let specifier;
        const params = {};
        if ((node.type === "mdxJsxFlowElement" || node.type === "mdxJsxTextElement") && node.name === TagName) {
          const value = flattenNode(node);
          if (value.length > 0) {
            for (const attr of node.attributes) {
              if (attr.type === "mdxJsxAttribute" && (typeof attr.value === "string" || attr.value === null)) {
                params[attr.name] = attr.value;
              }
            }
            specifier = value;
          }
        }
        if (!specifier) return;
        const targetPath = path2.resolve(
          "cwd" in params ? process.cwd() : path2.dirname(file),
          specifier
        );
        const asCode = params.lang || !specifier.endsWith(".md") && !specifier.endsWith(".mdx");
        queue.push(
          fs2.readFile(targetPath).then(async (content) => {
            compiler?.addDependency(targetPath);
            if (asCode) {
              const lang = params.lang ?? path2.extname(specifier).slice(1);
              Object.assign(node, {
                type: "code",
                lang,
                meta: params.meta,
                value: content.toString(),
                data: {}
              });
              return;
            }
            const parsed = processor.parse((0, import_gray_matter.default)(content).content);
            await update(parsed, targetPath, processor, compiler);
            Object.assign(
              parent && parent.type === "paragraph" ? parent : node,
              parsed
            );
          }).catch((e) => {
            console.warn(`failed to read file: ${targetPath}`, e);
          })
        );
        return "skip";
      }
    );
    await Promise.all(queue);
  }
  return async (tree, file) => {
    await update(tree, file.path, this, file.data._compiler);
  };
}

// src/utils/build-mdx.ts
var cache2 = /* @__PURE__ */ new Map();
async function buildMDX(cacheKey, source, options = {}) {
  const { filePath, frontmatter, data, ...rest } = options;
  let format = options.format;
  if (!format && filePath) {
    format = filePath.endsWith(".mdx") ? "mdx" : "md";
  }
  format ??= "mdx";
  const key = `${cacheKey}:${format}`;
  let cached = cache2.get(key);
  if (cached === void 0) {
    cached = (0, import_mdx.createProcessor)({
      outputFormat: "program",
      development: process.env.NODE_ENV === "development",
      ...rest,
      remarkPlugins: [remarkInclude, ...rest.remarkPlugins ?? []],
      format
    });
    cache2.set(key, cached);
  }
  return cached.process({
    value: source,
    path: filePath,
    data: {
      ...data,
      frontmatter,
      _compiler: options._compiler
    }
  });
}

// src/utils/git-timestamp.ts
var import_node_path = __toESM(require("path"), 1);
var import_node_fs = __toESM(require("fs"), 1);
var import_cross_spawn = require("cross-spawn");
var cache3 = /* @__PURE__ */ new Map();
function getGitTimestamp(file) {
  const cachedTimestamp = cache3.get(file);
  if (cachedTimestamp) return Promise.resolve(cachedTimestamp);
  return new Promise((resolve3, reject) => {
    const cwd = import_node_path.default.dirname(file);
    if (!import_node_fs.default.existsSync(cwd)) {
      resolve3(void 0);
      return;
    }
    const fileName = import_node_path.default.basename(file);
    const child = (0, import_cross_spawn.spawn)("git", ["log", "-1", '--pretty="%ai"', fileName], {
      cwd
    });
    let output;
    child.stdout.on("data", (d) => output = new Date(String(d)));
    child.on("close", () => {
      if (output) cache3.set(file, output);
      resolve3(output);
    });
    child.on("error", reject);
  });
}

// src/utils/schema.ts
var import_zod = require("zod");
var import_picocolors = __toESM(require("picocolors"), 1);
var metaSchema = import_zod.z.object({
  title: import_zod.z.string().optional(),
  pages: import_zod.z.array(import_zod.z.string()).optional(),
  description: import_zod.z.string().optional(),
  root: import_zod.z.boolean().optional(),
  defaultOpen: import_zod.z.boolean().optional(),
  icon: import_zod.z.string().optional()
});
var frontmatterSchema = import_zod.z.object({
  title: import_zod.z.string(),
  description: import_zod.z.string().optional(),
  icon: import_zod.z.string().optional(),
  full: import_zod.z.boolean().optional(),
  // Fumadocs OpenAPI generated
  _openapi: import_zod.z.object({}).passthrough().optional()
});
var ValidationError = class extends Error {
  constructor(message, issues) {
    super(message);
    this.issues = issues;
  }
  print() {
    console.error(
      [
        `[MDX] ${this.message}:`,
        ...this.issues.map(
          (issue) => import_picocolors.default.redBright(
            `- ${import_picocolors.default.bold(issue.path?.join(".") ?? "*")}: ${issue.message}`
          )
        )
      ].join("\n")
    );
  }
  toString() {
    return `${this.message}:
${this.issues.map((issue) => `  ${issue.path}: ${issue.message}`).join("\n")}`;
  }
};
async function validate(schema, data, context, errorMessage) {
  if (typeof schema === "function" && !("~standard" in schema)) {
    schema = schema(context);
  }
  if ("~standard" in schema) {
    const result = await schema["~standard"].validate(
      data
    );
    if (result.issues) {
      throw new ValidationError(errorMessage, result.issues);
    }
    return result.value;
  }
  return data;
}

// src/loader-mdx.ts
function parseQuery(query) {
  let collection;
  let hash;
  const parsed = (0, import_node_querystring.parse)(query.slice(1));
  if (parsed.collection && typeof parsed.collection === "string")
    collection = parsed.collection;
  if (parsed.hash && typeof parsed.hash === "string") hash = parsed.hash;
  return { collection, hash };
}
async function loader(source, callback) {
  this.cacheable(true);
  const context = this.context;
  const filePath = this.resourcePath;
  const { _ctx } = this.getOptions();
  const matter2 = (0, import_gray_matter2.default)(source);
  const {
    hash: configHash = await getConfigHash(_ctx.configPath),
    collection: collectionId
  } = parseQuery(this.resourceQuery);
  const config = await loadConfig(_ctx.configPath, configHash);
  let collection = collectionId !== void 0 ? config.collections.get(collectionId) : void 0;
  if (collection && collection.type === "docs") collection = collection.docs;
  if (collection && collection.type !== "doc") {
    collection = void 0;
  }
  let mdxOptions = collection?.mdxOptions;
  if (!mdxOptions) {
    const { getDefaultMDXOptions: getDefaultMDXOptions2 } = await Promise.resolve().then(() => (init_mdx_options(), mdx_options_exports));
    config._mdx_loader ??= {};
    const extendedOptions = config.global?.mdxOptions;
    config._mdx_loader.cachedProcessorOptions ??= typeof extendedOptions === "function" ? getDefaultMDXOptions2(await extendedOptions()) : getDefaultMDXOptions2(extendedOptions ?? {});
    mdxOptions = config._mdx_loader.cachedProcessorOptions;
  }
  if (collection?.schema) {
    matter2.data = await validate(
      collection.schema,
      matter2.data,
      {
        source,
        path: filePath
      },
      `invalid frontmatter in ${filePath}`
    );
  }
  let timestamp;
  if (config.global?.lastModifiedTime === "git")
    timestamp = (await getGitTimestamp(filePath))?.getTime();
  try {
    const lineOffset = "\n".repeat(
      this.mode === "development" ? lines(source) - lines(matter2.content) : 0
    );
    const file = await buildMDX(
      `${configHash}:${collectionId ?? "global"}`,
      lineOffset + matter2.content,
      {
        development: this.mode === "development",
        ...mdxOptions,
        filePath,
        frontmatter: matter2.data,
        data: {
          lastModified: timestamp
        },
        _compiler: this
      }
    );
    callback(void 0, String(file.value), file.map ?? void 0);
  } catch (error) {
    if (!(error instanceof Error)) throw error;
    const fpath = path4.relative(context, filePath);
    error.message = `${fpath}:${error.name}: ${error.message}`;
    callback(error);
  }
}
function lines(s) {
  let num = 0;
  for (const c of s) {
    if (c === "\n") num++;
  }
  return num;
}
