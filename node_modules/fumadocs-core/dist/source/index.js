import {
  joinPath,
  slash,
  splitPath
} from "../chunk-XMCPKVJQ.js";
import {
  __export
} from "../chunk-MLKGABMK.js";

// src/source/page-tree-builder.ts
var group = /^\((?<name>.+)\)$/;
var link = /^(?:\[(?<icon>[^\]]+)])?\[(?<name>[^\]]+)]\((?<url>[^)]+)\)$/;
var separator = /^---(?:\[(?<icon>[^\]]+)])?(?<name>.+)---|^---$/;
var rest = "...";
var restReversed = "z...a";
var extractPrefix = "...";
var excludePrefix = "!";
function isPageFile(node) {
  return "data" in node && node.format === "page";
}
function buildAll(nodes, ctx, skipIndex) {
  const output = [];
  const folders = [];
  for (const node of [...nodes].sort(
    (a, b) => a.file.name.localeCompare(b.file.name)
  )) {
    if (isPageFile(node)) {
      const localized = ctx.localeStorage?.read(
        joinPath(node.file.dirname, node.file.name),
        "page"
      );
      const treeNode = buildFileNode(localized ?? node, ctx);
      if (node.file.name === "index") {
        if (!skipIndex) output.unshift(treeNode);
      } else {
        output.push(treeNode);
      }
    }
    if ("children" in node) {
      folders.push(buildFolderNode(node, false, ctx));
    }
  }
  output.push(...folders);
  return output;
}
function resolveFolderItem(folder, item, ctx, idx, addedNodePaths) {
  if (item === rest || item === restReversed) return item;
  let match = separator.exec(item);
  if (match?.groups) {
    const node = {
      $id: `${folder.file.path}#${idx}`,
      type: "separator",
      icon: ctx.options.resolveIcon?.(match.groups.icon),
      name: match.groups.name
    };
    return [ctx.options.attachSeparator?.(node) ?? node];
  }
  match = link.exec(item);
  if (match?.groups) {
    const { icon, url, name } = match.groups;
    const isRelative = url.startsWith("/") || url.startsWith("#") || url.startsWith(".");
    const node = {
      type: "page",
      icon: ctx.options.resolveIcon?.(icon),
      name,
      url,
      external: !isRelative
    };
    return [ctx.options.attachFile?.(node) ?? node];
  }
  const isExcept = item.startsWith(excludePrefix), isExtract = item.startsWith(extractPrefix);
  let filename = item;
  if (isExcept) {
    filename = item.slice(excludePrefix.length);
  } else if (isExtract) {
    filename = item.slice(extractPrefix.length);
  }
  const path = joinPath(folder.file.path, filename);
  const itemNode = ctx.storage.readDir(path) ?? ctx.localeStorage?.read(path, "page") ?? ctx.storage.read(path, "page");
  if (!itemNode) return [];
  addedNodePaths.add(itemNode.file.path);
  if (isExcept) return [];
  if ("children" in itemNode) {
    const node = buildFolderNode(itemNode, false, ctx);
    return isExtract ? node.children : [node];
  }
  return [buildFileNode(itemNode, ctx)];
}
function buildFolderNode(folder, isGlobalRoot, ctx) {
  const metaPath = joinPath(folder.file.path, "meta");
  const meta = ctx.localeStorage?.read(metaPath, "meta") ?? ctx.storage.read(metaPath, "meta");
  const indexPath = joinPath(folder.file.path, "index");
  const indexFile = ctx.localeStorage?.read(indexPath, "page") ?? ctx.storage.read(indexPath, "page");
  const isRoot = meta?.data.root ?? isGlobalRoot;
  const index = indexFile ? buildFileNode(indexFile, ctx) : void 0;
  const addedNodePaths = /* @__PURE__ */ new Set();
  let children;
  if (!meta?.data.pages) {
    children = buildAll(folder.children, ctx, !isRoot);
  } else {
    const resolved = meta.data.pages.flatMap((item, i) => {
      return resolveFolderItem(folder, item, ctx, i, addedNodePaths);
    });
    const restNodes = buildAll(
      folder.children.filter((node2) => !addedNodePaths.has(node2.file.path)),
      ctx,
      !isRoot
    );
    const nodes = resolved?.flatMap((item) => {
      if (item === rest) {
        return restNodes;
      } else if (item === restReversed) {
        return restNodes.reverse();
      }
      return item;
    });
    children = nodes ?? restNodes;
  }
  const node = {
    type: "folder",
    name: meta?.data.title ?? index?.name ?? // resolve folder groups like (group_name)
    pathToName(group.exec(folder.file.name)?.[1] ?? folder.file.name),
    icon: ctx.options.resolveIcon?.(meta?.data.icon) ?? index?.icon,
    root: meta?.data.root,
    defaultOpen: meta?.data.defaultOpen,
    description: meta?.data.description,
    index: isRoot || indexFile && !addedNodePaths.has(indexFile.file.path) ? index : void 0,
    children,
    $id: folder.file.path,
    $ref: !ctx.options.noRef ? {
      metaFile: meta?.file.path
    } : void 0
  };
  return ctx.options.attachFolder?.(node, folder, meta) ?? node;
}
function buildFileNode(file, ctx) {
  const item = {
    $id: file.file.path,
    type: "page",
    name: file.data.data.title ?? pathToName(file.file.name),
    description: file.data.data.description,
    icon: ctx.options.resolveIcon?.(file.data.data.icon),
    url: ctx.getUrl(file.data.slugs, ctx.locale),
    $ref: !ctx.options.noRef ? {
      file: file.file.path
    } : void 0
  };
  return ctx.options.attachFile?.(item, file) ?? item;
}
function build(ctx) {
  const root = ctx.storage.root();
  const folder = buildFolderNode(root, true, ctx);
  return {
    $id: ctx.locale ? ctx.locale : "root",
    name: folder.name,
    children: folder.children
  };
}
function createPageTreeBuilder(getUrl) {
  return {
    build(options) {
      return build({
        options,
        builder: this,
        storage: options.storage,
        getUrl
      });
    },
    buildI18n({ i18n, ...options }) {
      const entries = i18n.languages.map((lang) => {
        const tree = build({
          options,
          getUrl,
          builder: this,
          locale: lang,
          storage: options.storages[i18n.defaultLanguage],
          localeStorage: options.storages[lang]
        });
        return [lang, tree];
      });
      return Object.fromEntries(entries);
    }
  };
}
function pathToName(name) {
  const result = [];
  for (const c of name) {
    if (result.length === 0) result.push(c.toLocaleUpperCase());
    else if (c === "-") result.push(" ");
    else result.push(c);
  }
  return result.join("");
}

// src/source/path.ts
function parseFilePath(path) {
  const segments = splitPath(slash(path));
  const dirname = segments.slice(0, -1).join("/");
  let name = segments.at(-1) ?? "";
  let ext = "";
  const dotIdx = name.lastIndexOf(".");
  if (dotIdx !== -1) {
    ext = name.substring(dotIdx);
    name = name.substring(0, dotIdx);
  }
  return {
    dirname,
    name,
    path: segments.join("/"),
    ext,
    flattenedPath: [dirname, name].filter((p) => p.length > 0).join("/")
  };
}
function parseFolderPath(path) {
  const segments = splitPath(slash(path));
  const base = segments.at(-1) ?? "";
  return {
    dirname: segments.slice(0, -1).join("/"),
    name: base,
    path: segments.join("/")
  };
}
function normalizePath(path) {
  const segments = splitPath(slash(path));
  if (segments[0] === "." || segments[0] === "..")
    throw new Error("It must not start with './' or '../'");
  return segments.join("/");
}

// src/source/file-system.ts
var file_system_exports = {};
__export(file_system_exports, {
  Storage: () => Storage
});
var Storage = class {
  constructor() {
    this.files = /* @__PURE__ */ new Map();
    this.folders = /* @__PURE__ */ new Map();
    this.rootFolder = {
      file: parseFolderPath(""),
      children: []
    };
    this.folders.set("", this.rootFolder);
  }
  /**
   * @param path - flattened path
   * @param format - file format
   */
  read(path, format) {
    return this.files.get(`${path}.${format}`);
  }
  readDir(path) {
    return this.folders.get(path);
  }
  root() {
    return this.rootFolder;
  }
  write(path, format, data) {
    const node = {
      format,
      file: parseFilePath(path),
      data
    };
    this.makeDir(node.file.dirname);
    this.readDir(node.file.dirname)?.children.push(node);
    this.files.set(
      joinPath(node.file.dirname, `${node.file.name}.${node.format}`),
      node
    );
  }
  list() {
    return [...this.files.values()];
  }
  makeDir(path) {
    const segments = splitPath(path);
    for (let i = 0; i < segments.length; i++) {
      const segment = segments.slice(0, i + 1).join("/");
      if (this.folders.has(segment)) continue;
      const folder = {
        file: parseFolderPath(segment),
        children: []
      };
      this.folders.set(folder.file.path, folder);
      this.readDir(folder.file.dirname)?.children.push(folder);
    }
  }
};

// src/source/load-files.ts
function loadFiles(files, options) {
  const { transformers = [] } = options;
  const storage = new Storage();
  for (const file of files) {
    const parsedPath = normalizePath(file.path);
    if (file.type === "page") {
      const slugs = file.slugs ?? options.getSlugs(parseFilePath(parsedPath));
      storage.write(parsedPath, file.type, {
        slugs,
        data: file.data
      });
    }
    if (file.type === "meta") {
      storage.write(parsedPath, file.type, file.data);
    }
  }
  for (const transformer of transformers) {
    transformer({
      storage,
      options
    });
  }
  return storage;
}
function loadFilesI18n(files, options) {
  const parser = options.i18n.parser === "dir" ? dirParser : dotParser;
  const storages = {};
  for (const lang of options.i18n.languages) {
    storages[lang] = loadFiles(
      files.flatMap((file) => {
        const [path, locale] = parser(normalizePath(file.path));
        if ((locale ?? options.i18n.defaultLanguage) === lang) {
          return {
            ...file,
            path
          };
        }
        return [];
      }),
      options
    );
  }
  return storages;
}
function dirParser(path) {
  const parsed = path.split("/");
  if (parsed.length >= 2) return [parsed.slice(1).join("/"), parsed[0]];
  return [path];
}
function dotParser(path) {
  const segs = path.split("/");
  if (segs.length === 0) return [path];
  const name = segs[segs.length - 1].split(".");
  if (name.length >= 3) {
    const locale = name.splice(name.length - 2, 1)[0];
    if (locale.length > 0 && !/\d+/.test(locale)) {
      segs[segs.length - 1] = name.join(".");
      return [segs.join("/"), locale];
    }
  }
  return [path];
}

// src/source/loader.ts
function indexPages(storages, getUrl, i18n) {
  const defaultLanguage = i18n?.defaultLanguage ?? "";
  const map = /* @__PURE__ */ new Map();
  const fileMapped = /* @__PURE__ */ new WeakMap();
  for (const item of storages[defaultLanguage].list()) {
    if (item.format === "meta") {
      fileMapped.set(item, fileToMeta(item));
    }
    if (item.format === "page") {
      const page = fileToPage(item, getUrl, defaultLanguage);
      fileMapped.set(item, page);
      map.set(`${defaultLanguage}.${page.slugs.join("/")}`, page);
      if (!i18n) continue;
      const path = joinPath(item.file.dirname, item.file.name);
      for (const lang of i18n.languages) {
        if (lang === defaultLanguage) continue;
        const localizedItem = storages[lang].read(path, "page");
        const localizedPage = fileToPage(localizedItem ?? item, getUrl, lang);
        if (localizedItem) {
          fileMapped.set(localizedItem, localizedPage);
        }
        map.set(`${lang}.${localizedPage.slugs.join("/")}`, localizedPage);
      }
    }
  }
  return {
    pages: map,
    getResultFromFile(file) {
      return fileMapped.get(file);
    }
  };
}
function createGetUrl(baseUrl, i18n) {
  const baseSlugs = baseUrl.split("/");
  return (slugs, locale) => {
    const hideLocale = i18n?.hideLocale ?? "never";
    let urlLocale;
    if (hideLocale === "never") {
      urlLocale = locale;
    } else if (hideLocale === "default-locale" && locale !== i18n?.defaultLanguage) {
      urlLocale = locale;
    }
    const paths = [...baseSlugs, ...slugs];
    if (urlLocale) paths.unshift(urlLocale);
    return `/${paths.filter((v) => v.length > 0).join("/")}`;
  };
}
function getSlugs(info) {
  return [...info.dirname.split("/"), info.name].filter(
    // filter empty folder names and file groups like (group_name)
    (v, i, arr) => {
      if (v.length === 0) return false;
      return i === arr.length - 1 ? v !== "index" : !/^\(.+\)$/.test(v);
    }
  );
}
function loader(options) {
  return createOutput(options);
}
function createOutput(options) {
  if (!options.url && !options.baseUrl) {
    console.warn("`loader()` now requires a `baseUrl` option to be defined.");
  }
  const { source, slugs: slugsFn = getSlugs } = options;
  const getUrl = options.url ?? createGetUrl(options.baseUrl ?? "/", options.i18n);
  const files = typeof source.files === "function" ? source.files() : source.files;
  const storages = options.i18n ? loadFilesI18n(files, {
    i18n: {
      ...options.i18n,
      parser: options.i18n.parser ?? "dot"
    },
    transformers: options.transformers,
    getSlugs: slugsFn
  }) : {
    "": loadFiles(files, {
      transformers: options.transformers,
      getSlugs: slugsFn
    })
  };
  const walker = indexPages(storages, getUrl, options.i18n);
  const builder = createPageTreeBuilder(getUrl);
  let pageTree;
  return {
    _i18n: options.i18n,
    get pageTree() {
      if (options.i18n) {
        pageTree ??= builder.buildI18n({
          storages,
          resolveIcon: options.icon,
          i18n: options.i18n,
          ...options.pageTree
        });
      } else {
        pageTree ??= builder.build({
          storage: storages[""],
          resolveIcon: options.icon,
          ...options.pageTree
        });
      }
      return pageTree;
    },
    set pageTree(v) {
      pageTree = v;
    },
    getPageByHref(href, { dir = "" } = {}) {
      const pages = Array.from(walker.pages.values());
      const [value, hash] = href.split("#", 2);
      if (value.startsWith(".") && (value.endsWith(".md") || value.endsWith(".mdx"))) {
        const hrefPath = joinPath(dir, value);
        const target2 = pages.find((item) => item.file.path === hrefPath);
        if (target2)
          return {
            page: target2,
            hash
          };
      }
      const target = pages.find((item) => item.url === value);
      if (target)
        return {
          page: target,
          hash
        };
    },
    getPages(language = options.i18n?.defaultLanguage ?? "") {
      const pages = [];
      for (const key of walker.pages.keys()) {
        if (key.startsWith(`${language}.`)) pages.push(walker.pages.get(key));
      }
      return pages;
    },
    getLanguages() {
      const list = [];
      if (!options.i18n) return list;
      for (const language of options.i18n.languages) {
        list.push({
          language,
          pages: this.getPages(language)
        });
      }
      return list;
    },
    getPage(slugs = [], language = options.i18n?.defaultLanguage ?? "") {
      return walker.pages.get(`${language}.${slugs.join("/")}`);
    },
    getNodeMeta(node, language = options.i18n?.defaultLanguage ?? "") {
      const ref = node.$ref?.metaFile;
      if (!ref) return;
      const file = storages[language].list().find((v) => v.format === "meta" && v.file.path === ref);
      if (file) return walker.getResultFromFile(file);
    },
    getNodePage(node, language = options.i18n?.defaultLanguage ?? "") {
      const ref = node.$ref?.file;
      if (!ref) return;
      const file = storages[language].list().find((v) => v.format === "page" && v.file.path === ref);
      if (file) return walker.getResultFromFile(file);
    },
    getPageTree(locale) {
      if (options.i18n) {
        return this.pageTree[locale ?? options.i18n.defaultLanguage];
      }
      return this.pageTree;
    },
    // @ts-expect-error -- ignore this
    generateParams(slug, lang) {
      if (options.i18n) {
        return this.getLanguages().flatMap(
          (entry) => entry.pages.map((page) => ({
            [slug ?? "slug"]: page.slugs,
            [lang ?? "lang"]: entry.language
          }))
        );
      }
      return this.getPages().map((page) => ({
        [slug ?? "slug"]: page.slugs
      }));
    }
  };
}
function fileToMeta(file) {
  return {
    file: file.file,
    data: file.data
  };
}
function fileToPage(file, getUrl, locale) {
  return {
    file: file.file,
    url: getUrl(file.data.slugs, locale),
    slugs: file.data.slugs,
    data: file.data.data,
    locale
  };
}
export {
  file_system_exports as FileSystem,
  createGetUrl,
  createPageTreeBuilder,
  getSlugs,
  loadFiles,
  loader,
  parseFilePath,
  parseFolderPath
};
