'use client';
import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { ChevronDown, ExternalLink } from '../../icons.js';
import { usePathname } from 'fumadocs-core/framework';
import { createContext, Fragment, useContext, useMemo, useRef, useState, } from 'react';
import Link from 'fumadocs-core/link';
import { useOnChange } from 'fumadocs-core/utils/use-on-change';
import { cn } from '../../utils/cn.js';
import { ScrollArea, ScrollViewport } from '../../components/ui/scroll-area.js';
import { isActive } from '../../utils/is-active.js';
import { Collapsible, CollapsibleContent, CollapsibleTrigger, } from '../../components/ui/collapsible.js';
import { useSidebar } from '../../contexts/sidebar.js';
import { cva } from 'class-variance-authority';
import { useTreeContext, useTreePath } from '../../contexts/tree.js';
import { useMediaQuery } from 'fumadocs-core/utils/use-media-query';
import { RemoveScroll } from 'react-remove-scroll';
import { Presence } from '@radix-ui/react-presence';
const itemVariants = cva('relative flex flex-row items-center gap-2 rounded-lg p-2 text-start text-fd-muted-foreground [overflow-wrap:anywhere] md:py-1.5 [&_svg]:size-4 [&_svg]:shrink-0', {
    variants: {
        active: {
            true: 'bg-fd-primary/10 text-fd-primary',
            false: 'transition-colors hover:bg-fd-accent/50 hover:text-fd-accent-foreground/80 hover:transition-none',
        },
    },
});
const Context = createContext(null);
const FolderContext = createContext(null);
export function Sidebar({ defaultOpenLevel = 0, prefetch = true, collapsible = true, ...props }) {
    const { open, setOpen, collapsed } = useSidebar();
    const context = useMemo(() => {
        return {
            defaultOpenLevel,
            prefetch,
            level: 1,
        };
    }, [defaultOpenLevel, prefetch]);
    const [hover, setHover] = useState(false);
    const timerRef = useRef(0);
    const closeTimeRef = useRef(0);
    // md
    const isMobile = useMediaQuery('(width < 768px)') ?? false;
    useOnChange(collapsed, () => {
        setHover(false);
        closeTimeRef.current = Date.now() + 150;
    });
    if (isMobile) {
        const state = open ? 'open' : 'closed';
        return (_jsxs(_Fragment, { children: [_jsx(Presence, { present: open, children: _jsx("div", { "data-state": state, className: "fixed z-40 inset-0 bg-black/30 backdrop-blur-sm data-[state=open]:animate-fd-fade-in data-[state=closed]:animate-fd-fade-out", onClick: () => setOpen(false) }) }), _jsx(Presence, { present: open, children: ({ present }) => (_jsx(RemoveScroll, { as: "aside", enabled: present, id: "nd-sidebar-mobile", ...props, "data-state": state, className: cn('fixed text-[15px] flex flex-col py-3 rounded-e-xl border-e start-0 inset-y-0 w-[85%] max-w-[380px] z-40 bg-fd-background data-[state=open]:animate-fd-enterFromLeft data-[state=closed]:animate-fd-exitToLeft', !present && 'invisible', props.className), children: _jsx(Context.Provider, { value: context, children: props.children }) })) })] }));
    }
    return (_jsx("aside", { id: "nd-sidebar", ...props, "data-collapsed": collapsed, className: cn('sticky top-(--fd-sidebar-top) z-20 bg-fd-card text-sm h-(--fd-sidebar-height) max-md:hidden', collapsible && [
            'transition-all',
            collapsed &&
                '-me-(--fd-sidebar-width) -translate-x-(--fd-sidebar-offset) rtl:translate-x-(--fd-sidebar-offset)',
            collapsed && hover && 'z-50 translate-x-0',
            collapsed && !hover && 'opacity-0',
        ], props.className), style: {
            '--fd-sidebar-offset': 'calc(var(--fd-sidebar-width) - 6px)',
            '--fd-sidebar-top': 'calc(var(--fd-banner-height) + var(--fd-nav-height))',
            '--fd-sidebar-height': 'calc(100dvh - var(--fd-banner-height) - var(--fd-nav-height))',
            ...props.style,
        }, onPointerEnter: (e) => {
            if (!collapsible ||
                !collapsed ||
                e.pointerType === 'touch' ||
                closeTimeRef.current > Date.now())
                return;
            window.clearTimeout(timerRef.current);
            setHover(true);
        }, onPointerLeave: (e) => {
            if (!collapsible || !collapsed || e.pointerType === 'touch')
                return;
            window.clearTimeout(timerRef.current);
            timerRef.current = window.setTimeout(() => {
                setHover(false);
                closeTimeRef.current = Date.now() + 150;
            }, Math.min(e.clientX, document.body.clientWidth - e.clientX) > 100
                ? 0
                : 500);
        }, children: _jsx("div", { className: "flex w-(--fd-sidebar-width) h-full max-w-full flex-col pt-1.5 ms-auto border-e", children: _jsx(Context.Provider, { value: context, children: props.children }) }) }));
}
export function SidebarHeader(props) {
    return (_jsx("div", { ...props, className: cn('flex flex-col gap-3 px-4 py-2', props.className), children: props.children }));
}
export function SidebarFooter(props) {
    return (_jsx("div", { ...props, className: cn('flex flex-col border-t px-4 py-3', props.className), children: props.children }));
}
export function SidebarViewport(props) {
    return (_jsx(ScrollArea, { ...props, className: cn('h-full', props.className), children: _jsx(ScrollViewport, { className: "p-4", style: {
                maskImage: 'linear-gradient(to bottom, transparent, white 12px)',
            }, children: props.children }) }));
}
export function SidebarSeparator(props) {
    const { level } = useInternalContext();
    return (_jsx("p", { ...props, className: cn('inline-flex items-center gap-2 mb-2 px-2 font-medium empty:mb-0 [&_svg]:size-4 [&_svg]:shrink-0', props.className), style: {
            paddingInlineStart: getOffset(level),
            ...props.style,
        }, children: props.children }));
}
export function SidebarItem({ icon, ...props }) {
    const pathname = usePathname();
    const active = props.href !== undefined && isActive(props.href, pathname, false);
    const { prefetch, level } = useInternalContext();
    return (_jsxs(Link, { ...props, "data-active": active, className: cn(itemVariants({ active }), props.className), prefetch: prefetch, style: {
            paddingInlineStart: getOffset(level),
            ...props.style,
        }, children: [_jsx(Border, { level: level, active: active }), icon ?? (props.external ? _jsx(ExternalLink, {}) : null), props.children] }));
}
export function SidebarFolder({ defaultOpen = false, ...props }) {
    const [open, setOpen] = useState(defaultOpen);
    useOnChange(defaultOpen, (v) => {
        if (v)
            setOpen(v);
    });
    return (_jsx(Collapsible, { open: open, onOpenChange: setOpen, ...props, children: _jsx(FolderContext.Provider, { value: useMemo(() => ({ open, setOpen }), [open]), children: props.children }) }));
}
export function SidebarFolderTrigger(props) {
    const { level } = useInternalContext();
    const { open } = useFolderContext();
    return (_jsxs(CollapsibleTrigger, { ...props, className: cn(itemVariants({ active: false }), 'w-full'), style: {
            paddingInlineStart: getOffset(level),
            ...props.style,
        }, children: [_jsx(Border, { level: level }), props.children, _jsx(ChevronDown, { "data-icon": true, className: cn('ms-auto transition-transform', !open && '-rotate-90') })] }));
}
export function SidebarFolderLink(props) {
    const { open, setOpen } = useFolderContext();
    const { prefetch, level } = useInternalContext();
    const pathname = usePathname();
    const active = props.href !== undefined && isActive(props.href, pathname, false);
    return (_jsxs(Link, { ...props, "data-active": active, className: cn(itemVariants({ active }), 'w-full', props.className), onClick: (e) => {
            if (e.target.hasAttribute('data-icon')) {
                setOpen((prev) => !prev);
                e.preventDefault();
            }
            else {
                setOpen((prev) => !active || !prev);
            }
        }, prefetch: prefetch, style: {
            paddingInlineStart: getOffset(level),
            ...props.style,
        }, children: [_jsx(Border, { level: level, active: active }), props.children, _jsx(ChevronDown, { "data-icon": true, className: cn('ms-auto transition-transform', !open && '-rotate-90') })] }));
}
export function SidebarFolderContent(props) {
    const ctx = useInternalContext();
    return (_jsx(CollapsibleContent, { ...props, className: cn('relative', props.className), children: _jsxs(Context.Provider, { value: useMemo(() => ({
                ...ctx,
                level: ctx.level + 1,
            }), [ctx]), children: [ctx.level === 1 && (_jsx("div", { className: "absolute w-px inset-y-0 bg-fd-border start-3" })), props.children] }) }));
}
export function SidebarCollapseTrigger(props) {
    const { collapsed, setCollapsed } = useSidebar();
    return (_jsx("button", { type: "button", "aria-label": "Collapse Sidebar", "data-collapsed": collapsed, ...props, onClick: () => {
            setCollapsed((prev) => !prev);
        }, children: props.children }));
}
function useFolderContext() {
    const ctx = useContext(FolderContext);
    if (!ctx)
        throw new Error('Missing sidebar folder');
    return ctx;
}
function useInternalContext() {
    const ctx = useContext(Context);
    if (!ctx)
        throw new Error('<Sidebar /> component required.');
    return ctx;
}
/**
 * Render sidebar items from page tree
 */
export function SidebarPageTree(props) {
    const { root } = useTreeContext();
    return useMemo(() => {
        const { Separator, Item, Folder } = props.components ?? {};
        function renderSidebarList(items, level) {
            return items.map((item, i) => {
                if (item.type === 'separator') {
                    if (Separator)
                        return _jsx(Separator, { item: item }, i);
                    return (_jsxs(SidebarSeparator, { className: cn(i !== 0 && 'mt-6'), children: [item.icon, item.name] }, i));
                }
                if (item.type === 'folder') {
                    const children = renderSidebarList(item.children, level + 1);
                    if (Folder)
                        return (_jsx(Folder, { item: item, level: level, children: children }, i));
                    return (_jsx(PageTreeFolder, { item: item, children: children }, i));
                }
                if (Item)
                    return _jsx(Item, { item: item }, item.url);
                return (_jsx(SidebarItem, { href: item.url, external: item.external, icon: item.icon, children: item.name }, item.url));
            });
        }
        return (_jsx(Fragment, { children: renderSidebarList(root.children, 1) }, root.$id));
    }, [props.components, root]);
}
function PageTreeFolder({ item, ...props }) {
    const { defaultOpenLevel, level } = useInternalContext();
    const path = useTreePath();
    return (_jsxs(SidebarFolder, { defaultOpen: (item.defaultOpen ?? defaultOpenLevel >= level) || path.includes(item), children: [item.index ? (_jsxs(SidebarFolderLink, { href: item.index.url, external: item.index.external, ...props, children: [item.icon, item.name] })) : (_jsxs(SidebarFolderTrigger, { ...props, children: [item.icon, item.name] })), _jsx(SidebarFolderContent, { children: props.children })] }));
}
function getOffset(level) {
    return `calc(var(--spacing) * ${level > 1 ? (level - 1) * 3 + 3 : 2})`;
}
function Border({ level, active }) {
    if (level <= 1)
        return null;
    return (_jsx("div", { className: cn('absolute w-px inset-y-3 z-[2] start-3 md:inset-y-2', active && 'bg-fd-primary') }));
}
